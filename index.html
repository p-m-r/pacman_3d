<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Pacman 3D</title>
</head>
<style>
	body {
		margin: 0;
		padding: 0;
	}
	#main-canvas {
		width: 100%;
		height: 100%;
		position: absolute;
	}
	#top-canvas {
		position: relative;
		top: 0;
		left: 0;
	}
</style>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/PointerLockControls.js"></script>
<script src="js/csg.js"></script>
<script src="js/ThreeCSG.js"></script>

<body>
	<script>
		'use strict';
		let alpha = 0;
		const WIDTH = window.innerWidth;
		const HEIGHT = window.innerHeight;
		let renderer = new THREE.WebGLRenderer({antialias: true});
		let scene = new THREE.Scene();
		renderer.setSize(WIDTH, HEIGHT);
		document.body.appendChild(renderer.domElement);
		renderer.domElement.id = "main-canvas";


		let camera = new THREE.PerspectiveCamera(70, WIDTH/HEIGHT);
		camera.position.z = 15;
		camera.position.y = 6;
		camera.position.x = 15;
		camera.up = new THREE.Vector3(0, 1, 0);
		let cameraVector = new THREE.Vector3(150, 6, 150);
		camera.lookAt(cameraVector);
		scene.add(camera);

		let rendererTop = new THREE.WebGLRenderer({antialias: true});
		rendererTop.setSize(200,200);
		document.body.appendChild(rendererTop.domElement);
		rendererTop.domElement.id = "top-canvas";
		let cameraTop = new THREE.PerspectiveCamera(70, 1);
		cameraTop.position.z = 150;
		cameraTop.position.y = 300;
		cameraTop.position.x = 150;
		cameraTop.up = new THREE.Vector3(0, 1, 0);
		cameraTop.lookAt(new THREE.Vector3(150, 0, 150));
		scene.add(cameraTop);


		//let controls = new THREE.OrbitControls(camera, renderer.domElement);

		let box = new THREE.BoxGeometry(10, 10, 10);
		let material = new THREE.MeshLambertMaterial({color: 0x0095DD});

		let cube = new THREE.Mesh(box, material);
		cube.translateX(-40);
		cube.translateY(35);
		scene.add(cube);

		let rotX = 0.0;
		let rotY = 0.0;
		let rotZ = 0.0;

		let light = new THREE.DirectionalLight(0xFFFFFF);
		light.position.set(10, 10, 5);
		scene.add(light);

		let ambientLight = new THREE.AmbientLight(0x404040);
		scene.add(ambientLight);

		const worldMap = [
			['e','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','b','f'],
			['a',' ',' ','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','c'],
			['a','-','i','j','-','i','d','d','j','-','i','d','d','d','d','d','d','j','-','i','d','d','j','-','i','j','-','c'],
			['a','-','c','a','-','c',' ',' ','a','-','c','e','b','b','b','b','f','a','-','c',' ',' ','a','-','c','a','-','c'],
			['a','-','c','a','-','l','b','b','k','-','c','a','-','-','-','-','c','a','-','l','b','b','k','-','c','a','-','c'],
			['a','-','c','a','-','-','-','-','-','-','c','a','-','i','j','-','c','a','-','-','-','-','-','-','c','a','-','c'],
			['a','-','c','h','d','j','-','i','j','-','c','a','-','c','a','-','c','a','-','i','j','-','i','d','g','a','-','c'],
			['a','-','l','b','b','k','-','c','a','-','l','k','-','c','a','-','l','k','-','c','a','-','l','b','b','k','-','c'],
			['a','-','-','-','-','-','-','c','a','-','-','-','-','c','a','-','-','-','-','c','a','-','-','-','-','-','-','c'],
			['h','d','j','-','i','d','d','g','h','d','d','j','-','c','a','-','i','d','d','g','h','d','d','j','-','i','d','g'],
			[' ',' ','a','-','l','b','b','f','e','b','b','k','-','l','k','-','l','b','b','f','e','b','b','k','-','c',' ',' '],
			[' ',' ','a','-','-','-','-','c','a','-','-','-','-','-','-','-','-','-','-','c','a','-','-','-','-','c',' ',' '],
			['b','b','k','-','i','j','-','c','a','-','i','d','d',' ',' ','d','d','j','-','c','a','-','i','j','-','l','b','b'],
			['-','-','-','-','c','a','-','l','k','-','c',' ',' ',' ',' ',' ',' ','a','-','l','k','-','c','a','-','-','-','-'],
			['d','d','d','d','g','a','-','-','-','-','c',' ',' ',' ',' ',' ',' ','a','-','-','-','-','c','h','d','d','d','d'],
			['b','b','b','b','f','a','-','i','j','-','c',' ',' ',' ',' ',' ',' ','a','-','i','j','-','c','e','b','b','b','b'],
			['-','-','-','-','c','a','-','c','a','-','l','b','b','b','b','b','b','k','-','c','a','-','c','a','-','-','-','-'],
			['d','d','j','-','l','k','-','c','a','-','-','-','-','-','-','-','-','-','-','c','a','-','l','k','-','i','d','d'],
			[' ',' ','a','-','-','-','-','c','h','d','d','j','-','i','j','-','i','d','d','g','a','-','-','-','-','c',' ',' '],
			[' ',' ','a','-','i','j','-','l','b','b','b','k','-','c','a','-','l','b','b','b','k','-','i','j','-','c',' ',' '],
			[' ',' ','a','-','c','a','-','-','-','-','-','-','-','c','a','-','-','-','-','-','-','-','c','a','-','c',' ',' '],
			[' ',' ','a','-','c','h','d','d','j','-','i','j','-','c','a','-','i','j','-','i','d','d','g','a','-','c',' ',' '],
			['e','b','k','-','l','b','b','b','k','-','c','a','-','l','k','-','c','a','-','l','b','b','b','k','-','l','b','f'],
			['a','-','-','-','-','-','-','-','-','-','c','a','-','-','-','-','c','a','-','-','-','-','-','-','-','-','-','c'],
			['a','-','i','d','d','j','-','i','j','-','c','h','d','d','d','d','g','a','-','i','j','-','i','d','d','j','-','c'],
			['a','-','c','e','b','k','-','c','a','-','l','b','b','b','b','b','b','k','-','c','a','-','l','b','f','a','-','c'],
			['a','-','c','a','-','-','-','c','a','-','-','-','-','-','-','-','-','-','-','c','a','-','-','-','c','a','-','c'],
			['a','-','c','a','-','i','d','g','h','d','d','j','-','i','j','-','i','d','d','g','h','d','j','-','c','a','-','c'],
			['a','-','l','k','-','l','b','b','b','b','b','k','-','c','a','-','l','b','b','b','b','b','k','-','l','k','-','c'],
			['a','-','-','-','-','-','-','-','-','-','-','-','-','c','a','-','-','-','-','-','-','-','-','-','-','-','-','c'],
			['h','d','d','d','d','d','d','d','d','d','d','d','d','g','h','d','d','d','d','d','d','d','d','d','d','d','d','g']
		];

		let cubeLeftGeometry = new THREE.BoxGeometry(4, 10, 10);
		let cubeLeft = new THREE.Mesh(cubeLeftGeometry, material);

		let cubeTopGeometry = new THREE.BoxGeometry(10, 10, 4);
		let cubeTop = new THREE.Mesh(cubeTopGeometry, material);

		let cubeRightGeometry = new THREE.BoxGeometry(4, 10, 10);
		let cubeRight = new THREE.Mesh(cubeRightGeometry, material);

		let cubeBottomGeometry = new THREE.BoxGeometry(10, 10, 4);
		let cubeBottom = new THREE.Mesh(cubeBottomGeometry, material);

		let topLeftCornerGeometry = new THREE.Geometry();
		cubeLeft.translateX(-3);
		cubeLeft.translateZ(-3);
		cubeLeft.updateMatrix();
		cubeTop.translateZ(-6);
		cubeTop.updateMatrix();
		topLeftCornerGeometry.merge(cubeTop.geometry, cubeTop.matrix);
		topLeftCornerGeometry.merge(cubeLeft.geometry, cubeLeft.matrix);
		let topLeftCorner = new THREE.Mesh(topLeftCornerGeometry, material);

		let topRightCornerGeometry = new THREE.Geometry();
		cubeRight.translateZ(5);
		cubeRight.translateX(8);
		cubeRight.updateMatrix();
		cubeTop.translateZ(8);
		cubeTop.translateX(5);
		cubeTop.updateMatrix();
		topRightCornerGeometry.merge(cubeTop.geometry, cubeTop.matrix);
		topRightCornerGeometry.merge(cubeRight.geometry, cubeRight.matrix);
		let topRightCorner = new THREE.Mesh(topRightCornerGeometry, material);
		

		let bottomRightCornerGeometry = new THREE.Geometry();
		cubeRight.updateMatrix();
		cubeBottom.translateZ(8);
		cubeBottom.translateX(5);
		cubeBottom.updateMatrix();
		bottomRightCornerGeometry.merge(cubeBottom.geometry, cubeBottom.matrix);
		bottomRightCornerGeometry.merge(cubeRight.geometry, cubeRight.matrix);
		let bottomRightCorner = new THREE.Mesh(bottomRightCornerGeometry, material);
		

		let bottomLeftCornerGeometry = new THREE.Geometry();
		cubeLeft.translateZ(8);
		cubeLeft.translateX(5);
		cubeLeft.updateMatrix();
		cubeBottom.updateMatrix();
		bottomLeftCornerGeometry.merge(cubeBottom.geometry, cubeBottom.matrix);
		bottomLeftCornerGeometry.merge(cubeLeft.geometry, cubeLeft.matrix);
		let bottomLeftCorner = new THREE.Mesh(bottomLeftCornerGeometry, material);

		let smallCubeGeometry = new THREE.BoxGeometry(4,10,4);
		let smallCube = new THREE.Mesh(smallCubeGeometry, material);


		let moveForward = false;
		let moveBackward = false;
		let moveLeft = false;
		let moveRight = false;
		let mouseX;

		let velocity = new THREE.Vector3();
		let direction = new THREE.Vector3();

		velocity.y = 0;

		let prevTime = performance.now();

		//let controls = new THREE.PointerLockControls(camera, renderer.domElement);

		//scene.add(controls.getObject());
		//controls.lock();

		//document.addEventListener('mousemove', onMouseMove, false);
		document.addEventListener('keydown', onKeyDown, false);
		document.addEventListener('keyup', onKeyUp, false);

		let raycaster = new THREE.Raycaster();

		let cubes = [];
		let balls = [];
		createCubesAndBalls();

		drawLines();
		render();
		checkIfCollision();

		function render() {
			requestAnimationFrame(render);
			rotX += 0.015;
			rotY += 0.005;
			cube.rotation.set(rotX, rotY, rotZ);
			renderer.render(scene, camera);
			rendererTop.render(scene, cameraTop);
			animate();
		}
		
		function createCubesAndBalls() {
			const size = 10;
			let box = new THREE.BoxGeometry(size, size, size);
			let material = new THREE.MeshLambertMaterial({color: 0x0095DD});
			let cube = new THREE.Mesh(box, material);
			let sphere = new THREE.SphereGeometry(2, 5, 5);
			let sphereMaterial = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
			let ball = new THREE.Mesh(sphere, sphereMaterial);
			for (let j = 0; j < worldMap.length; ++j) {
				for (let i = 0; i < worldMap[0].length; ++i) {
					let copy;
					if (worldMap[j][i] === 'a') {
						copy = cubeLeft.clone();
						copy.position.set(i*size + 2, 0, j*size + 5);
						cubes.push(copy);
					} else if ((worldMap[j][i]) === 'b') {
						copy = cubeTop.clone();
						copy.position.set(i*size + 5, 0, j*size + 2);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'c') {
						copy = cubeRight.clone();
						copy.position.set(i*size + 8, 0, j*size + 5);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'd') {
						copy = cubeBottom.clone();
						copy.position.set(i*size + 5, 0, j*size + 8);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'e') {
						copy = topLeftCorner.clone();
						copy.position.set(i*size + 5, 0, j*size + 8);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'f') {
						copy = topRightCorner.clone();
						copy.position.set(i*size, 0, j*size);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'g') {
						copy = bottomRightCorner.clone();
						copy.position.set(i*size, 0, j*size);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'h') {
						copy = bottomLeftCorner.clone();
						copy.position.set(i*size, 0, j*size);
						scene.add(copy);
					} else if (worldMap[j][i] === 'i') {
						copy = smallCube.clone();
						copy.position.set(i*size + 8, 0, j*size + 8);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'j') {
						copy = smallCube.clone();
						copy.position.set(i*size + 2, 0, j*size + 8);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'k') {
						copy = smallCube.clone();
						copy.position.set(i*size + 2, 0,  j*size + 2);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'l') {
						copy = smallCube.clone();
						copy.position.set(i*size + 8, 0, j*size + 2);
						cubes.push(copy);
					} else if (worldMap[j][i] === 'x') {
						copy = ball.clone();
						copy.position.set(i*size + size*0.5 - 3, 0, j*size + size*0.5 - 3);
						scene.add(copy);
					}
				}
			}
			cubes.forEach( cube => {
				//if (cube.position.z > 150) {
					scene.add(cube);
				//}
			})
		}

		function drawLines() {
			let space = 10;
			for (let i = 0; i < 32; i++) {
				let geometryX = new THREE.Geometry();
				let geometryZ = new THREE.Geometry();
				geometryX.vertices.push(new THREE.Vector3(i*space,0,0), new THREE.Vector3(i*space,0,320));
				geometryZ.vertices.push(new THREE.Vector3(0,0,i*space), new THREE.Vector3(320,0,i*space));
				let materialX = new THREE.LineBasicMaterial({color: 0xFF0000});
				let materialZ = new THREE.LineBasicMaterial({color: 0x00FF00});
				let lineX = new THREE.Line(geometryX, materialX);
				let lineZ = new THREE.Line(geometryZ, materialZ);
				scene.add(lineX);
				scene.add(lineZ);
			}
		}

		function onKeyDown(event) {
			switch ( event.keyCode ) {
				case 38: // up
				case 87: // w
					moveForward = true;
					break;
				case 37: // left
				case 65: // a
					moveLeft = true;
					break;
				case 40: // down
				case 83: // s
					moveBackward = true;
					break;
				case 39: // right
				case 68: // d
					moveRight = true;
					break;
				case 32: // space
					if ( canJump === true ) velocity.y += 350;
					canJump = false;
					break;
			}
		}

		function onKeyUp(event) {
			switch ( event.keyCode ) {
				case 38: // up
				case 87: // w
					moveForward = false;
					break;
				case 37: // left
				case 65: // a
					moveLeft = false;
					break;
				case 40: // down
				case 83: // s
					moveBackward = false;
					break;
				case 39: // right
				case 68: // d
					moveRight = false;
					break;
			}
		}
		/*function onMouseMove(event) {
			cameraVector.x -= event.movementX;
			//cameraVector.y -= event.movementY;
			camera.lookAt(cameraVector);
		}*/
		function animate() {
			/*let time = performance.now();
			let delta = (time - prevTime)/1000;
			//console.log(delta);
			velocity.x -= velocity.x * 10.0 * delta;
			velocity.z -= velocity.z * 10.0 * delta;

			direction.z = Number(moveForward) - Number(moveBackward);
			direction.x = Number(moveLeft) - Number(moveRight);

			if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
			if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
*/			if (moveLeft || moveRight) {
				updateAlpha();
				updateDirection();
			}
			
			//if (moveForward)
				updateVelocity();
			//if (!checkIfCollision()) {
				camera.position.x += velocity.x*2;
				camera.position.z += velocity.z*2;
			//}

			
			//camera.lookAt(cameraVector);

			//controls.getObject().translateX(velocity.x * delta);
			//controls.getObject().translateZ(velocity.z * delta);
			//camera.position.x += velocity.x * delta;
			//camera.position.z += velocity.z * delta;
			//prevTime = time;
			//console.log(`x: ${direction.z} y: ${direction.y} z: ${direction.x}`);
			//direction.z = 1;
			//direction.x = 1;
		}
		function updateAlpha() {
			if (moveRight)
				alpha += 0.07;
			if (moveLeft)
				alpha -= 0.07;
		}
		function updateDirection() {
			cameraVector.x = 500*Math.cos(alpha);
			cameraVector.z = 500*Math.sin(alpha);
			camera.lookAt(cameraVector);
			checkIfCollision();
		}
		function updateVelocity() {
			if (moveForward) {
				velocity.x = cameraVector.x - camera.position.x;
				velocity.z = cameraVector.z - camera.position.z;
				velocity.normalize();
			} else {
				velocity.x = 0;
				velocity.z = 0;
			}
		}
		function checkIfCollision() {
			let origin = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
			//console.log(origin);
			//console.log(cameraVector);
			let direction = new THREE.Vector3(cameraVector.x - origin.x, cameraVector.y - origin.y, cameraVector.z - origin.z);
			direction.normalize();
			console.log(direction);
			raycaster.set(origin, direction);
			//raycaster.near = 1;
			//raycaster.far = 100;
			//console.log(scene.children);
			//console.log(raycaster.ray)
			console.log(cubes);
			let intersects = raycaster.intersectObjects(cubes);
			console.log(intersects);
			return intersects.length;
		}
	</script>
	
</body>
</html>